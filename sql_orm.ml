(* ORM layer for Sqlite *)
open Printf

module Schema = struct
    type t =
    |Text
    |Blob
    |Int
    |Foreign of string
    |ForeignMany of string
    |Date
 
    type s = {
        name: string;
        ty: t;
    }

    let text n = {name=n; ty=Text}
    let blob n = {name=n; ty=Blob}
    let date n = {name=n; ty=Date}
    let foreign n f = {name=n; ty=(Foreign f)}
    let foreign_many n f = {name=n; ty=(ForeignMany f)}

    type collection = (string * s list) list

    let make (f:collection) = f

    let to_ocaml_type = function
    |Text -> "string"
    |Blob -> "string" (* watch out for 16MB limit *)
    |Int -> "int64"
    |Foreign x -> sprintf "%s.t" (String.capitalize x)
    |ForeignMany x -> sprintf "%s.t" "XXX"
    |Date -> "int64"

    let to_sql_type = function
    |Text -> "text"
    |Blob -> "blob"
    |Int -> "integer"
    |Foreign _ -> "integer"
    |ForeignMany _ -> assert false
    |Date -> "integer"

    let to_sql_type_wrapper = function
    |Text -> "Sqlite3.Data.TEXT"
    |Blob -> "Sqlite3.Data.BLOB"
    |Int -> "Sqlite3.Data.INT"
    |Foreign _ -> "Sqlite3.Data.INT"
    |ForeignMany _ -> assert false
    |Date -> "Sqlite3.Data.INT"

    let sql_decls (fs: s list) =
     let fs = List.filter (fun x -> match x.ty with |ForeignMany _ -> false |_ -> true) fs in
     let pid = "id integer primary key autoincrement" in
      let sqls = List.map (fun f ->
        sprintf "%s %s" f.name (to_sql_type f.ty) 
      ) fs in
      String.concat ", " (pid::sqls)

end

let all = Schema.make [
  "contacts" , [
    Schema.text "file_name";
    Schema.text "uid";
    Schema.text "abrecord";
    Schema.text "first_name";
    Schema.text "last_name";
    Schema.date "mtime";
  ];

  "people" , [
    Schema.text "service_name";
    Schema.text "service_id";
    Schema.foreign "contact_id" "contacts"
  ];

  "mtypes" , [
    Schema.text "mtype";
    Schema.text "label";
    Schema.text "icon";
    Schema.text "implements";
  ];

  "lifedb" , [
    Schema.text "file_name";
    Schema.date "ctime";
    Schema.foreign "mtype" "mtypes";
    Schema.foreign "people_from" "people";
    Schema.foreign_many "people_to" "people";
    Schema.text "summary";
  ];

  "attachments" , [
    Schema.foreign "lifedb_id" "lifedb";
    Schema.text "file_name";
  ];

]

open Printer_utils.Printer

let output_module e (module_name, fields) =
  let foreign_fields, fields = List.partition (fun x -> match x.Schema.ty with Schema.ForeignMany _ -> true|_ -> false) fields in
  print_module e module_name (fun e ->
    print_object e "t" (fun e ->
      List.iter (fun f ->
          e.p (sprintf "%s : %s;" f.Schema.name (Schema.to_ocaml_type f.Schema.ty));
      ) fields;
    );
    e.p "let init db =";
    indent_fn e (fun e ->
      e.p (sprintf "let sql = \"create table if not exists %s (%s);\" in" module_name (Schema.sql_decls fields));
      e.p "db#exec sql";
    );
    e.nl();
    print_comment e "General get function for any of the columns";
    e.p (sprintf "let get %s db =" (String.concat " " (List.map (fun f -> sprintf "?(%s=None)" f.Schema.name) fields)));
    indent_fn e (fun e ->
      print_comment e "assemble the SQL query string";
      let wheres = List.map (fun f -> sprintf "(match %s with |None -> \"\" |Some _ -> \"%s=?\");" f.Schema.name f.Schema.name) fields in
      e.p "let wheres = String.concat \" && \"  [";
      list_iter_indent e (fun e -> e.p) wheres;
      e.p "] in";
      e.p "let q=\"select * from %s where \" ^ wheres in";
      e.p "let stmt=Sqlite3.prepare db q in";
      print_comment e "bind the position variables to the statement";
      e.p "let bindpos = ref 1 in";
      List.iter (fun f ->
         e.p (sprintf "ignore(match %s with |None -> () |Some v ->" f.Schema.name);
         indent_fn e (fun e ->
           e.p (sprintf "Sql_access.db_must_ok (fun () -> Sqlite3.bind stmt !bindpos (%s v));" (Schema.to_sql_type_wrapper f.Schema.ty));
           e.p "incr bindpos";
         );
         e.p ");";
      ) fields;
      print_comment e "execute the SQL query";
      e.p "(fun () ->";
      indent_fn e (fun e ->
        e.p "match Sqlite3.step stmt with";
        e.p "|Sqlite3.Rc.ROW -> ()";
        indent_fn e (fun e ->
           ()  
        );
      );
      e.p ")"
  
    );
  )

let _ =
  let e = init_printer ~msg:(Some "(* autogenerated by sql_orm *)") stdout in
  e.p "open Sql_access";
  List.iter (output_module e) all;
  ()
   
